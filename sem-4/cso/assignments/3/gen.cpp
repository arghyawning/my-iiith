#include <iostream>
#include <fstream>
#include <random>
#include <map>
#include <string.h>

// -----------------------------------------------------------------------------------
// 							Random data generation
// -----------------------------------------------------------------------------------
std::random_device rd;  // Will be used to obtain a seed for the random number engine
std::mt19937 gen; // Standard mersenne_twister_engine which we will seed with rd()
/**
 * Create a `std::uniform_real_distribution<T> dis(l, r)`, then
 * use dis to transform the random unsigned int generated by gen into a 
 * double in [l, r). Each call to dis(gen) generates a new random type T
 */

// -----------------------------------------------------------------------------------
// 							Matrix generation
// -----------------------------------------------------------------------------------
/**
 * Creates a matrix of type T, dimensions MxN and returns a pointer to malloc'd memory. 
 * Can additionally pass arguments l and r to specify a range to generate random 
 * numbers between.
 */
template<typename T>
T* create_rand_matrix(int M, int N, T l = -1.0, T r = 1.0){
    std::uniform_real_distribution<T> dis(l, r);
	T *mat = (T*) malloc(sizeof(T) * M * N);
	for(int i=0; i<(M*N); i++) mat[i] = dis(gen);
	return mat;
}

/**
 * Returns a random number of type T. Can additionally pass arguments l and r to 
 * specify a range to generate random numbers between.
 */
template<typename T>
T get_rand_num(T l = -1.0, T r = 1.0){
    std::uniform_real_distribution<T> dis(l, r);
    return dis(gen);
}

// -----------------------------------------------------------------------------------
// 							Benchmark code
// -----------------------------------------------------------------------------------

typedef std::vector<std::pair<int, int>> vii;
#define ss second
#define ff first
std::map<std::string, std::vector<vii>> config;

void __init(){
	// Initialize the mersenne twister engine
	gen = std::mt19937(rd());

	// Load config options into the config map
	/**
	 * The goal here is to benchmark the functions for varying sizes in memory. Ultimately
	 * memory will end up becoming the benchmark for large vector / matrix operations.
	 * Here is a reasonable guide to picking config sizes: 
	 * + 1-3 options should fit in L1-L2 cache
	 * + 4-6 options should fit in L2-L3 cache
	 * + 7-9 options should overflow cache and start occupying large amounts of system memory
	 */

	config["sgemm"] = 	{{{99, 99}, {99, 99}, {99, 99}}, {{159, 159}, {159, 159}, {159, 159}}, \
						 {{262, 262}, {262, 262}, {262, 262}}, {{383, 383}, {383, 383}, {383, 383}}, \
						 {{537, 537}, {537, 537}, {537, 537}}, {{723, 723}, {723, 723}, {723, 723}}, \
						 {{1127, 1127}, {1127, 1127}, {1127, 1127}}, {{1447, 1447}, {1447, 1447}, {1447, 1447}}, \
						 {{1772, 1772}, {1772, 1772}, {1772, 1772}}, {{2047, 2047}, {2047, 2047}, {2047, 2047}}, \
						 {{2270, 2270}, {2270, 2270}, {2270, 2270}}, {{2876, 2876}, {2876, 2876}, {2876, 2876}}, \
						 {{4095, 4095}, {4095, 4095}, {4095, 4095}}};
}

/**
 * Given the config, creates the requested spec and then writes it to the fs filestream
 */
template<typename T>
void write_config(vii &conf, std::fstream &fs, T l=-1.0, T r=1.0){
	for(auto [n, m]:conf){
		fs.write((const char*) &n, sizeof(int));
		fs.write((const char*) &m, sizeof(int));
		T *elem = (T*) create_rand_matrix<T>(n, m, l, r);
		fs.write((const char*) elem, sizeof(T)*n*m);
		free(elem);
	}
}

/**
 * Given an input filestream fs, reads in arguments of the form 
 * std::pair<int, int> dim, n*m matrix of floats or doubles.
 */
template<typename T>
std::vector<std::pair<T*, std::pair<int, int>>> parse_input(std::ifstream &fs){
	int n, m;
	std::vector<std::pair<T*, std::pair<int, int>>> ret;
	while(!fs.eof()){
		n = -1;
		fs.read((char*) &n, sizeof(int));
		if(n == -1) break;
		fs.read((char*) &m, sizeof(int));
		T *elem = (T*) malloc(sizeof(T)*n*m);
		fs.read((char*) elem, sizeof(T)*n*m);
		ret.push_back({elem, {n, m}});
	}
	return ret;
}

/**
 * Writes the generated result matrix to filestream fs
 */
template<typename T>
void write_verification(std::fstream &fs, int N, int M, T *data){
	fs.write((const char*) data, sizeof(T) * N * M);
}

template<typename T>
void _gemm_verify(std::ifstream &ifs, std::fstream &ofs, void (*gemm) (const int, const T*, const T*, T*));

#define INPUT_DIR "input/"
#define VERIF_DIR "verification/"

void my_gemm (const int N, const float* A, const float* B, float* C){
	const int lda = N;
    // Compute C = A * B + C
    for (int i=0; i < N; i++) 
        for(int j=0; j < N; j++)
        	for(int k=0; k < N; k++)
        		C[i*lda + j] += A[i*lda + k] * B[k*lda + j];
}

int main(void){
	__init();

	// Generate input data from config
	for(auto &[benchmark, confs]:config){
		int num_confs = confs.size();
		for(int i=0; i<num_confs; i++){
			std::cout<<"["<<i+1<<"/"<<num_confs<<"]\tGenerating input files for "<<benchmark<<"\n";
			std::fstream fs(INPUT_DIR + benchmark + "/" + std::to_string(i+1),  std::ios::out | std::ios::binary);
			if(benchmark[0] == 's') write_config<float>(confs[i], fs);
			else if(benchmark[0] == 'd') write_config<double>(confs[i], fs);
		}
	}

	// Generate verification data by running Verifier on it and saving result
	for(auto &[benchmark, confs]:config){
		int num_confs = confs.size();
		for(int i=0; i<num_confs; i++){
			std::cout<<"["<<i+1<<"/"<<num_confs<<"]\tRunning Verifier on input file for "<<benchmark<<"\n";
			std::ifstream ifs(INPUT_DIR + benchmark + "/" + std::to_string(i+1),  std::ios::out | std::ios::binary);
			std::fstream ofs(VERIF_DIR + benchmark + "/" + std::to_string(i+1),  std::ios::out | std::ios::binary);
			if (benchmark == "sgemm") _gemm_verify<float>(ifs, ofs, my_gemm);
		}
	}
}

template<typename T>
void _gemm_verify(std::ifstream &ifs, std::fstream &ofs, void (*gemm) (const int, const T*, const T*, T*)){
	std::vector<std::pair<T*, std::pair<int, int>>> args = parse_input<T>(ifs);
	int N = args[0].ss.ff;
	T *A = args[0].ff;
	T *B = args[1].ff;
	T *C = args[2].ff;
	gemm(N, A, B, C);
	write_verification<T>(ofs, N, N, C);
	for(auto &arg:args) free(arg.ff);
}
